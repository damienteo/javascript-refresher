{"ast":null,"code":"import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker'; // ReactDOM.render(<App />, document.getElementById('root'));\n// var -> function\n// let -> block (should use let keyword when you need to re-assign variables)\n// const -> block\n// function sayHello() {\n// \tfor (var i = 0; i < 5; i++) {\n// \t\tconsole.log(i);\n// \t}\n// \tconsole.log(i);\n// }\n// sayHello();\n// //values stored in var are still accessible outside of the curly braces\n// function sayHello() {\n// \tfor (let i = 0; i < 5; i++) {\n// \t\tconsole.log(i);\n// \t}\n// \tconsole.log(i);\n// }\n// sayHello();\n// //values stored in let are also available within the curly braces block\n// const x = 1;\n// x = 2;\n// //x is now read-only, cannot be re-defined\n//objects in javascript are collections of key-value pairs\n// const person = {\n// \tname: 'john',\n// \twalk: function(){}\n// \ttalk() {} //easier way to define method with ES6\n// }\n// walk is a method within the person object.\n// person.talk();\n// person.name = '';\n// person['name'] = 'John';\n// //We use bracket when we don't know ahead of time what property or method we are going to access.\n// const targetMember = 'name';\n// person[targetMember.value] = 'John';\n// const person = {\n// \tname: 'john',\n// \twalk: function(){\n// \t\tconsole.log(this);\n// \t}\n// }\n// person.walk();\n//this will refer to const person\n// const walk = person.walk;\n// walk(); //this will be undefined\n//if we call a function as a method in an object, 'this' will be a reference to the object. If we call a function as a standalone, 'this' will refer to the window\n//The bind method will return a new instacne of the function, and set 'this' to point to the object.\n// const walk = person.walk.bind(person);\n// walk(); \n// const square = function(number) {\n// \treturn number*number;\n// }\n// const square = (number) => {\n// \treturn number*number;\n// }\n// const square = number => {\n// \treturn number*number;\n// }\n// const square = () => {\n// \treturn number*number;\n// } //no paremeters\n// const square = number => {\n// \tnumber*number;\n// }\n// const square = number => number*number;\n// console.log(square(5));\n// const jobs = [\n// \t{ id: 1, isActive: true },\n// \t{ id: 2, isActive: true },\n// \t{ id: 3, isActive: false }\n// ];\n// // const activeJobs = jobs.filter(function(job){return job.isActive});\n// const activeJobs = jobs.filter(job => job.isActive);\n// arrow functions do not re-bind 'this'\n// const person  = {\n// \ttalk() {\n// \t\tconsole.log(\"this\", this);\n// \t}\n// }\n// person.talk();\n//'this' will refer to the object\n// const person  = {\n// \ttalk() {\n// \t\tsetTimeout(function() {\n// \t\t\tconsole.log(\"this\", this);\n// \t\t}, 1000);\n// \t}\n// }\n// person.talk();\n// 'this' will refer to window, sd talk() will be a standalone function\n// const person  = {\n// \ttalk() {\n// \t\tvar self = this;\n// \t\tsetTimeout(function() {\n// \t\t\tconsole.log(\"self\", self);\n// \t\t}, 1000);\n// \t}\n// }\n// person.talk();\n//one way to settle the 'this' issue\n// const person  = {\n// \ttalk() {\n// \t\tsetTimeout(() => {\n// \t\t\tconsole.log(\"this\", this);\n// \t\t}, 1000);\n// \t}\n// }\n// person.talk();\n// or we can use the arrow function, which does not re-bind the 'this' keyword\n// const colors =['red', 'green', 'blue'];\n// // const items = colors.map(function(color) {\n// // \treturn ('<li> + color + </li>')\n// // });\n// const items = colors.map(color => `li>${color}</li>`);\n// //${} is an argument placeholder. \n// console.log(items);\n// const address = {\n// \tstreet: '',\n// \tcity: '',\n// \tcountry: ''\n// }\n// const street = address.street;\n// const city = address.city;\n// const country = address.country;\n// const { street, city, country } = address; // this line is equivalent to the previous three lines\n// const { street: st } = address;\n// const st = address.street;\n// // this is objectd destructuring\n// const first = [1, 2, 3];\n// const second = [4, 5, 6];\n// // const combine = first.concat(second); //old way of combining\n// // const combine = [...first, 'a', ...second, 'b']; \n// //the spread operator is used with '...'. it also allows us to add additional elements in the center, as well as other places.\n// //Using the spread operator, we can also clone arrays.\n// const clone = [...first];\n// console.log(first);\n// console.log(clone);\n// const first = { name: 'John' };\n// const second = { job: 'Driver'};\n// const combined = {...first, ...second, location: 'Earth'};\n// console.log (combined);\n// const person = {\n// \tname: \"John\",\n// \twalk() {\n// \t\tconsole.log(\"walk\");\n// \t}\n// }\n// const person2 = {\n// \tname: \"John\",\n// \twalk() {\n// \t\tconsole.log(\"walk\");\n// \t}\n// } //duplication of the wlak method\n// class Person {\n// \tconstructor(name) {\n// \t\tthis.name = name;\n// \t}\n// \twalk() {\n// \t\tconsole.log(\"walk\");\n// \t}\n// }\n//for class, the first letter is capital\n// const person = new Person('John');\n// console.log(person);\n// person.walk();\n// const person2 = new Person('James');\n// console.log(person2);\n// class Person {\n// \tconstructor(name) {\n// \t\tthis.name = name;\n// \t}\n// \twalk() {\n// \t\tconsole.log(\"walk\");\n// \t}\n// }\n// class Teacher {\n// \tteacher() {\n// \t\tconsole.log(\"teacher\");\n// \t}\n// }\n//All teachers should be able to walk, but how? We can use inheritance or composition.\n//We can have the teacher class inherit from the person class.\n//we  can also import external modules\n\nimport { Teacher } from './teacher';\nvar teacher = new Teacher('John', 'phd');\nconsole.log(teacher);\nteacher.teach();\nteacher.walk(); // If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\n\nserviceWorker.unregister();","map":{"version":3,"sources":["/home/damienteo/portfolio/javascript-refresher/src/index.js"],"names":["React","ReactDOM","App","serviceWorker","Teacher","teacher","console","log","teach","walk","unregister"],"mappings":"AAAA,OAAOA,KAAP,MAAkB,OAAlB;AACA,OAAOC,QAAP,MAAqB,WAArB;AACA,OAAO,aAAP;AACA,OAAOC,GAAP,MAAgB,OAAhB;AACA,OAAO,KAAKC,aAAZ,MAA+B,iBAA/B,C,CAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;;AAEA,SAASC,OAAT,QAAwB,WAAxB;AAEA,IAAMC,OAAO,GAAG,IAAID,OAAJ,CAAa,MAAb,EAAqB,KAArB,CAAhB;AAEAE,OAAO,CAACC,GAAR,CAAYF,OAAZ;AACAA,OAAO,CAACG,KAAR;AACAH,OAAO,CAACI,IAAR,G,CAEA;AACA;AACA;;AACAN,aAAa,CAACO,UAAd","sourcesContent":["import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\n// ReactDOM.render(<App />, document.getElementById('root'));\n\n// var -> function\n// let -> block (should use let keyword when you need to re-assign variables)\n// const -> block\n\n// function sayHello() {\n// \tfor (var i = 0; i < 5; i++) {\n// \t\tconsole.log(i);\n// \t}\n// \tconsole.log(i);\n// }\n\n// sayHello();\n// //values stored in var are still accessible outside of the curly braces\n\n// function sayHello() {\n// \tfor (let i = 0; i < 5; i++) {\n// \t\tconsole.log(i);\n// \t}\n// \tconsole.log(i);\n// }\n\n// sayHello();\n// //values stored in let are also available within the curly braces block\n\n// const x = 1;\n// x = 2;\n// //x is now read-only, cannot be re-defined\n\n//objects in javascript are collections of key-value pairs\n\n// const person = {\n// \tname: 'john',\n// \twalk: function(){}\n// \ttalk() {} //easier way to define method with ES6\n// }\n\n// walk is a method within the person object.\n\n// person.talk();\n// person.name = '';\n// person['name'] = 'John';\n// //We use bracket when we don't know ahead of time what property or method we are going to access.\n\n// const targetMember = 'name';\n// person[targetMember.value] = 'John';\n\n// const person = {\n// \tname: 'john',\n// \twalk: function(){\n// \t\tconsole.log(this);\n// \t}\n// }\n\n// person.walk();\n//this will refer to const person\n\n// const walk = person.walk;\n// walk(); //this will be undefined\n\n//if we call a function as a method in an object, 'this' will be a reference to the object. If we call a function as a standalone, 'this' will refer to the window\n\n//The bind method will return a new instacne of the function, and set 'this' to point to the object.\n\n// const walk = person.walk.bind(person);\n// walk(); \n\n// const square = function(number) {\n// \treturn number*number;\n// }\n\n// const square = (number) => {\n// \treturn number*number;\n// }\n\n// const square = number => {\n// \treturn number*number;\n// }\n\n// const square = () => {\n// \treturn number*number;\n// } //no paremeters\n\n// const square = number => {\n// \tnumber*number;\n// }\n\n// const square = number => number*number;\n\n// console.log(square(5));\n\n// const jobs = [\n// \t{ id: 1, isActive: true },\n// \t{ id: 2, isActive: true },\n// \t{ id: 3, isActive: false }\n// ];\n\n// // const activeJobs = jobs.filter(function(job){return job.isActive});\n\n// const activeJobs = jobs.filter(job => job.isActive);\n\n// arrow functions do not re-bind 'this'\n\n// const person  = {\n// \ttalk() {\n// \t\tconsole.log(\"this\", this);\n// \t}\n// }\n\n// person.talk();\n//'this' will refer to the object\n\n// const person  = {\n// \ttalk() {\n// \t\tsetTimeout(function() {\n// \t\t\tconsole.log(\"this\", this);\n// \t\t}, 1000);\n// \t}\n// }\n\n// person.talk();\n// 'this' will refer to window, sd talk() will be a standalone function\n\n\n\n// const person  = {\n// \ttalk() {\n// \t\tvar self = this;\n// \t\tsetTimeout(function() {\n// \t\t\tconsole.log(\"self\", self);\n// \t\t}, 1000);\n// \t}\n// }\n\n// person.talk();\n//one way to settle the 'this' issue\n\n// const person  = {\n// \ttalk() {\n// \t\tsetTimeout(() => {\n// \t\t\tconsole.log(\"this\", this);\n// \t\t}, 1000);\n// \t}\n// }\n\n// person.talk();\n// or we can use the arrow function, which does not re-bind the 'this' keyword\n\n// const colors =['red', 'green', 'blue'];\n\n// // const items = colors.map(function(color) {\n// // \treturn ('<li> + color + </li>')\n// // });\n\n// const items = colors.map(color => `li>${color}</li>`);\n// //${} is an argument placeholder. \n// console.log(items);\n\n// const address = {\n// \tstreet: '',\n// \tcity: '',\n// \tcountry: ''\n// }\n\n// const street = address.street;\n// const city = address.city;\n// const country = address.country;\n\n// const { street, city, country } = address; // this line is equivalent to the previous three lines\n\n// const { street: st } = address;\n// const st = address.street;\n// // this is objectd destructuring\n\n// const first = [1, 2, 3];\n// const second = [4, 5, 6];\n\n// // const combine = first.concat(second); //old way of combining\n\n// // const combine = [...first, 'a', ...second, 'b']; \n// //the spread operator is used with '...'. it also allows us to add additional elements in the center, as well as other places.\n\n// //Using the spread operator, we can also clone arrays.\n\n// const clone = [...first];\n// console.log(first);\n// console.log(clone);\n\n// const first = { name: 'John' };\n// const second = { job: 'Driver'};\n\n// const combined = {...first, ...second, location: 'Earth'};\n\n// console.log (combined);\n\n// const person = {\n// \tname: \"John\",\n// \twalk() {\n// \t\tconsole.log(\"walk\");\n// \t}\n// }\n\n// const person2 = {\n// \tname: \"John\",\n// \twalk() {\n// \t\tconsole.log(\"walk\");\n// \t}\n// } //duplication of the wlak method\n\n// class Person {\n// \tconstructor(name) {\n// \t\tthis.name = name;\n// \t}\n\n// \twalk() {\n// \t\tconsole.log(\"walk\");\n// \t}\n// }\n\n//for class, the first letter is capital\n\n// const person = new Person('John');\n\n// console.log(person);\n// person.walk();\n\n// const person2 = new Person('James');\n// console.log(person2);\n\n// class Person {\n// \tconstructor(name) {\n// \t\tthis.name = name;\n// \t}\n\n// \twalk() {\n// \t\tconsole.log(\"walk\");\n// \t}\n// }\n\n// class Teacher {\n// \tteacher() {\n// \t\tconsole.log(\"teacher\");\n// \t}\n// }\n\n//All teachers should be able to walk, but how? We can use inheritance or composition.\n\n//We can have the teacher class inherit from the person class.\n\n//we  can also import external modules\n\nimport { Teacher } from './teacher';\n\nconst teacher = new Teacher ('John', 'phd');\n\nconsole.log(teacher);\nteacher.teach();\nteacher.walk();\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"]},"metadata":{},"sourceType":"module"}